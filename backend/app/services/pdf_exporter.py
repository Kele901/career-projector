"""
PDF Export Service
Generates PDF reports for career recommendations.
"""

from typing import List, Dict, Any
from datetime import datetime
from io import BytesIO
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib import colors
from reportlab.lib.units import inch
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT


class PDFExporter:
    """Service for generating PDF reports"""
    
    def __init__(self):
        self.styles = getSampleStyleSheet()
        self._setup_custom_styles()
    
    def _setup_custom_styles(self):
        """Setup custom paragraph styles"""
        self.styles.add(ParagraphStyle(
            name='CustomTitle',
            parent=self.styles['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#4F46E5'),
            spaceAfter=30,
            alignment=TA_CENTER
        ))
        
        self.styles.add(ParagraphStyle(
            name='SectionHeader',
            parent=self.styles['Heading2'],
            fontSize=16,
            textColor=colors.HexColor('#4F46E5'),
            spaceAfter=12,
            spaceBefore=12
        ))
        
        self.styles.add(ParagraphStyle(
            name='SubSection',
            parent=self.styles['Heading3'],
            fontSize=14,
            textColor=colors.HexColor('#6366F1'),
            spaceAfter=8,
            spaceBefore=8
        ))
        
        self.styles.add(ParagraphStyle(
            name='BodyText',
            parent=self.styles['Normal'],
            fontSize=10,
            spaceAfter=6
        ))
        
        self.styles.add(ParagraphStyle(
            name='Footer',
            parent=self.styles['Normal'],
            fontSize=8,
            textColor=colors.gray,
            alignment=TA_CENTER
        ))
    
    def generate_recommendations_report(
        self,
        recommendations_data: Dict[str, Any],
        cv_data: Dict[str, Any]
    ) -> BytesIO:
        """
        Generate a PDF report for career recommendations.
        
        Args:
            recommendations_data: Recommendation results
            cv_data: CV data including skills and work experience
            
        Returns:
            BytesIO buffer containing the PDF
        """
        buffer = BytesIO()
        doc = SimpleDocTemplate(
            buffer,
            pagesize=letter,
            rightMargin=0.75*inch,
            leftMargin=0.75*inch,
            topMargin=0.75*inch,
            bottomMargin=0.75*inch
        )
        
        # Build the story (content)
        story = []
        
        # Title Page
        story.extend(self._create_title_page(cv_data))
        
        # Executive Summary
        story.extend(self._create_executive_summary(recommendations_data))
        
        # Top Recommendations
        story.extend(self._create_recommendations_section(recommendations_data))
        
        # Skills Analysis
        story.extend(self._create_skills_analysis(cv_data, recommendations_data))
        
        # Learning Roadmap
        story.extend(self._create_learning_roadmap(recommendations_data))
        
        # Footer
        story.append(Spacer(1, 0.5*inch))
        story.append(Paragraph(
            f"Generated by Career Projector on {datetime.now().strftime('%B %d, %Y')}",
            self.styles['Footer']
        ))
        story.append(Paragraph(
            "Visit https://career-projector.com for more insights",
            self.styles['Footer']
        ))
        
        # Build PDF
        doc.build(story)
        buffer.seek(0)
        return buffer
    
    def _create_title_page(self, cv_data: Dict[str, Any]) -> List:
        """Create title page elements"""
        elements = []
        
        # Title
        elements.append(Spacer(1, 1.5*inch))
        elements.append(Paragraph(
            "Career Recommendations Report",
            self.styles['CustomTitle']
        ))
        
        # CV Info
        elements.append(Spacer(1, 0.5*inch))
        elements.append(Paragraph(
            f"<b>CV:</b> {cv_data.get('filename', 'N/A')}",
            self.styles['BodyText']
        ))
        elements.append(Paragraph(
            f"<b>Generated:</b> {datetime.now().strftime('%B %d, %Y at %I:%M %p')}",
            self.styles['BodyText']
        ))
        
        if cv_data.get('years_experience'):
            elements.append(Paragraph(
                f"<b>Years of Experience:</b> {cv_data.get('years_experience')} years",
                self.styles['BodyText']
            ))
        
        if cv_data.get('education_level'):
            elements.append(Paragraph(
                f"<b>Education Level:</b> {cv_data.get('education_level')}",
                self.styles['BodyText']
            ))
        
        elements.append(PageBreak())
        return elements
    
    def _create_executive_summary(self, recommendations_data: Dict[str, Any]) -> List:
        """Create executive summary section"""
        elements = []
        
        elements.append(Paragraph("Executive Summary", self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        recommendations = recommendations_data.get('recommendations', [])
        if not recommendations:
            elements.append(Paragraph(
                "No recommendations available.",
                self.styles['BodyText']
            ))
            return elements
        
        # Summary stats
        total_paths = len(recommendations)
        excellent_matches = sum(1 for r in recommendations if r.get('match_score', 0) >= 0.7)
        good_matches = sum(1 for r in recommendations if 0.5 <= r.get('match_score', 0) < 0.7)
        
        # Get top match
        top_match = max(recommendations, key=lambda r: r.get('match_score', 0))
        
        summary_text = f"""
        Based on your skills and experience, we've identified <b>{total_paths}</b> potential career paths 
        for you. Your profile shows <b>{excellent_matches}</b> excellent matches (70%+ compatibility) and 
        <b>{good_matches}</b> good matches (50-69% compatibility).
        <br/><br/>
        <b>Your top career match is: {top_match.get('pathway', 'N/A')}</b> 
        with a {int(top_match.get('match_score', 0) * 100)}% compatibility score.
        """
        
        elements.append(Paragraph(summary_text, self.styles['BodyText']))
        elements.append(Spacer(1, 0.3*inch))
        
        return elements
    
    def _create_recommendations_section(self, recommendations_data: Dict[str, Any]) -> List:
        """Create detailed recommendations section"""
        elements = []
        
        elements.append(Paragraph("Career Path Recommendations", self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        recommendations = recommendations_data.get('recommendations', [])[:10]  # Top 10
        
        for i, rec in enumerate(recommendations, 1):
            # Pathway name and score
            match_score = int(rec.get('match_score', 0) * 100)
            elements.append(Paragraph(
                f"<b>{i}. {rec.get('pathway', 'Unknown')} ({match_score}% Match)</b>",
                self.styles['SubSection']
            ))
            
            # Description
            if rec.get('description'):
                elements.append(Paragraph(
                    rec.get('description', ''),
                    self.styles['BodyText']
                ))
            
            # Reasoning
            if rec.get('reasoning'):
                elements.append(Paragraph(
                    f"<i>{rec.get('reasoning', '')}</i>",
                    self.styles['BodyText']
                ))
            
            # Recommended skills
            if rec.get('recommended_skills'):
                skills = rec.get('recommended_skills', [])
                if isinstance(skills, list):
                    skills_text = ", ".join(skills[:8])
                    elements.append(Paragraph(
                        f"<b>Skills to learn:</b> {skills_text}",
                        self.styles['BodyText']
                    ))
            
            elements.append(Spacer(1, 0.15*inch))
        
        return elements
    
    def _create_skills_analysis(
        self,
        cv_data: Dict[str, Any],
        recommendations_data: Dict[str, Any]
    ) -> List:
        """Create skills analysis section"""
        elements = []
        
        elements.append(PageBreak())
        elements.append(Paragraph("Skills Analysis", self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        # Current skills
        skills = cv_data.get('skills', [])
        if skills:
            elements.append(Paragraph(
                f"<b>Current Skills ({len(skills)} total):</b>",
                self.styles['SubSection']
            ))
            
            # Group skills by category
            skills_by_category = {}
            for skill in skills:
                category = skill.get('skill_category', 'Other')
                if category not in skills_by_category:
                    skills_by_category[category] = []
                skills_by_category[category].append(skill.get('skill_name', 'Unknown'))
            
            # Create table
            table_data = [['Category', 'Skills']]
            for category, skill_names in sorted(skills_by_category.items()):
                table_data.append([
                    category,
                    ", ".join(skill_names[:10]) + ("..." if len(skill_names) > 10 else "")
                ])
            
            table = Table(table_data, colWidths=[1.5*inch, 5*inch])
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4F46E5')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ]))
            elements.append(table)
            elements.append(Spacer(1, 0.3*inch))
        
        return elements
    
    def _create_learning_roadmap(self, recommendations_data: Dict[str, Any]) -> List:
        """Create learning roadmap section"""
        elements = []
        
        elements.append(Paragraph("Next Steps & Learning Roadmap", self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        # Aggregate recommended skills
        all_skills = {}
        recommendations = recommendations_data.get('recommendations', [])
        
        for rec in recommendations[:5]:  # Top 5 recommendations
            skills = rec.get('recommended_skills', [])
            if isinstance(skills, list):
                for skill in skills:
                    all_skills[skill] = all_skills.get(skill, 0) + 1
        
        # Sort by frequency
        sorted_skills = sorted(all_skills.items(), key=lambda x: x[1], reverse=True)[:15]
        
        elements.append(Paragraph(
            "<b>Priority Skills to Learn:</b> (Based on top career matches)",
            self.styles['BodyText']
        ))
        elements.append(Spacer(1, 0.1*inch))
        
        # Create priority skills table
        if sorted_skills:
            table_data = [['Skill', 'Relevance', 'Priority']]
            for skill, count in sorted_skills:
                relevance = "High" if count >= 3 else "Medium" if count >= 2 else "Low"
                priority = "ðŸ”¥ Critical" if count >= 4 else "âš¡ High" if count >= 3 else "âœ“ Good"
                table_data.append([skill, relevance, priority])
            
            table = Table(table_data, colWidths=[3*inch, 1.5*inch, 2*inch])
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4F46E5')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.lightblue),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ]))
            elements.append(table)
        
        elements.append(Spacer(1, 0.3*inch))
        
        # Recommendations
        elements.append(Paragraph(
            "<b>Recommended Actions:</b>",
            self.styles['SubSection']
        ))
        
        actions = [
            "1. Focus on the high-priority skills listed above",
            "2. Take online courses or certifications in your target career path",
            "3. Build projects to demonstrate your new skills",
            "4. Update your CV as you acquire new skills",
            "5. Network with professionals in your target field",
            "6. Track your progress regularly using Career Projector"
        ]
        
        for action in actions:
            elements.append(Paragraph(action, self.styles['BodyText']))
        
        return elements
    
    def generate_comparison_report(
        self,
        cv1_data: Dict[str, Any],
        cv2_data: Dict[str, Any]
    ) -> BytesIO:
        """
        Generate a PDF comparison report for two CVs.
        
        Args:
            cv1_data: First CV data
            cv2_data: Second CV data
            
        Returns:
            BytesIO buffer containing the PDF
        """
        buffer = BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter)
        
        story = []
        
        # Title
        story.append(Paragraph("CV Comparison Report", self.styles['CustomTitle']))
        story.append(Spacer(1, 0.3*inch))
        
        # Comparison table
        story.append(Paragraph("Comparison Overview", self.styles['SectionHeader']))
        
        comparison_data = [
            ['Metric', 'CV 1', 'CV 2', 'Change'],
            ['Skills Count', 
             str(len(cv1_data.get('skills', []))),
             str(len(cv2_data.get('skills', []))),
             f"+{len(cv2_data.get('skills', [])) - len(cv1_data.get('skills', []))}"],
            ['Upload Date',
             cv1_data.get('upload_date', 'N/A'),
             cv2_data.get('upload_date', 'N/A'),
             'N/A'],
        ]
        
        table = Table(comparison_data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        story.append(table)
        
        doc.build(story)
        buffer.seek(0)
        return buffer

